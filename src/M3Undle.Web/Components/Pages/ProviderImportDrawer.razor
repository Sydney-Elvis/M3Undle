@using M3Undle.Web.Contracts.Providers
@using System.Text.Json
@inject HttpClient Http

<MudDialog>
    <DialogContent>
        <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mb-3">Providers discovered in M3UNDLE_CONFIG_DIR</MudText>

        @if (!string.IsNullOrWhiteSpace(_importError))
        {
            <MudAlert Severity="Severity.Error" Variant="Variant.Outlined" Class="mb-3">@_importError</MudAlert>
        }
        @if (!string.IsNullOrWhiteSpace(_loadError))
        {
            <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined" Class="mb-3">@_loadError</MudAlert>
        }

        @if (_isLoading)
        {
            <MudProgressCircular Indeterminate="true" />
        }
        else if (_configProviders.Count == 0)
        {
            <MudAlert Severity="Severity.Info" Variant="Variant.Outlined">No providers found in config.yaml.</MudAlert>
        }
        else
        {
            <MudTable Items="_configProviders" Hover="true" Dense="true">
                <HeaderContent>
                    <MudTh>Name</MudTh>
                    <MudTh>Playlist URL</MudTh>
                    <MudTh>Status</MudTh>
                    <MudTh></MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd>@context.Name</MudTd>
                    <MudTd>@context.PlaylistUrl</MudTd>
                    <MudTd>
                        @if (context.MissingEnvVars.Count > 0)
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Error">
                                Missing: @string.Join(", ", context.MissingEnvVars)
                            </MudChip>
                        }
                        else if (IsAlreadyImported(context.Name))
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Success">Imported</MudChip>
                        }
                        else if (_probeStates.TryGetValue(context.Name, out var probe))
                        {
                            if (probe.IsProbing)
                            {
                                <MudProgressCircular Indeterminate="true" Size="Size.Small" />
                            }
                            else if (probe.Ok == true)
                            {
                                <MudChip T="string" Size="Size.Small" Color="Color.Success">@($"{probe.ChannelCount:N0} channels")</MudChip>
                            }
                            else
                            {
                                <MudTooltip Text="@probe.Error">
                                    <MudChip T="string" Size="Size.Small" Color="Color.Error">Failed</MudChip>
                                </MudTooltip>
                            }
                        }
                        else
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Default">Ready</MudChip>
                        }
                    </MudTd>
                    <MudTd>
                        <MudStack Row="true" Spacing="1" AlignItems="AlignItems.Center">
                            @if (!IsAlreadyImported(context.Name) && context.MissingEnvVars.Count == 0)
                            {
                                <MudButton Variant="Variant.Outlined" Color="Color.Secondary" Size="Size.Small"
                                           Disabled="@IsProbing(context.Name)"
                                           OnClick="() => ProbeAsync(context.Name)">Test</MudButton>
                                var opts = GetImportOptions(context.Name);
                                <MudCheckBox T="bool" @bind-Value="opts.IncludeVod" Size="Size.Small" Label="VOD"
                                             Disabled="@(_importingName == context.Name)" />
                                <MudCheckBox T="bool" @bind-Value="opts.IncludeSeries" Size="Size.Small" Label="Series"
                                             Disabled="@(_importingName == context.Name)" />
                            }
                            <MudButton Variant="Variant.Filled" Color="Color.Primary" Size="Size.Small"
                                       Disabled="@(IsAlreadyImported(context.Name) || context.MissingEnvVars.Count > 0 || _importingName == context.Name)"
                                       OnClick="() => ImportAsync(context.Name)">
                                @(_importingName == context.Name ? "Importing..." : "Import")
                            </MudButton>
                        </MudStack>
                    </MudTd>
                </RowTemplate>
            </MudTable>
        }
    </DialogContent>
    <DialogActions>
        <MudButton StartIcon="@Icons.Material.Filled.Refresh" OnClick="LoadAsync" Disabled="_isLoading">Reload</MudButton>
        <MudSpacer />
        <MudButton OnClick="() => MudDialog.Close()">Close</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter] IMudDialogInstance MudDialog { get; set; } = default!;
    [Parameter] public EventCallback<string> OnImported { get; set; }

    private readonly List<ConfigYamlProviderDto> _configProviders = [];
    private readonly List<ProviderDto> _importedProviders = [];
    private bool _isLoading;
    private string? _loadError;
    private string? _importError;
    private string? _importingName;
    private readonly Dictionary<string, ProbeState> _probeStates = new();
    private readonly Dictionary<string, ImportOptions> _importOptions = new();

    private sealed class ProbeState
    {
        public bool IsProbing { get; set; }
        public bool? Ok { get; set; }
        public int? ChannelCount { get; set; }
        public string? Error { get; set; }
    }

    private sealed class ImportOptions
    {
        public bool IncludeVod { get; set; }
        public bool IncludeSeries { get; set; }
    }

    protected override async Task OnInitializedAsync() => await LoadAsync();

    private async Task LoadAsync()
    {
        _isLoading = true;
        _loadError = null;
        StateHasChanged();

        try
        {
            var configTask = Http.GetFromJsonAsync<List<ConfigYamlProviderDto>>("/api/v1/providers/config/available");
            var importedTask = Http.GetFromJsonAsync<List<ProviderDto>>("/api/v1/providers");
            await Task.WhenAll(configTask, importedTask);

            _configProviders.Clear();
            _configProviders.AddRange(configTask.Result ?? []);
            _importedProviders.Clear();
            _importedProviders.AddRange(importedTask.Result ?? []);
        }
        catch (Exception ex)
        {
            _loadError = $"Failed to load providers: {ex.Message}";
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private ImportOptions GetImportOptions(string name)
    {
        if (!_importOptions.TryGetValue(name, out var opts))
        {
            opts = new ImportOptions();
            _importOptions[name] = opts;
        }
        return opts;
    }

    private bool IsAlreadyImported(string name) => _importedProviders.Any(p => p.Name == name);

    private bool IsProbing(string name) => _probeStates.TryGetValue(name, out var s) && s.IsProbing;

    private async Task ProbeAsync(string name)
    {
        if (!_probeStates.TryGetValue(name, out var state))
        {
            state = new ProbeState();
            _probeStates[name] = state;
        }

        state.IsProbing = true;
        state.Ok = null;
        state.ChannelCount = null;
        state.Error = null;
        StateHasChanged();

        try
        {
            var response = await Http.PostAsJsonAsync("/api/v1/providers/config/probe",
                new ProbeConfigProviderRequest { Name = name });

            if (!response.IsSuccessStatusCode)
            {
                state.Ok = false;
                state.Error = await ReadErrorAsync(response);
                return;
            }

            var result = await response.Content.ReadFromJsonAsync<ProbeConfigProviderResultDto>();
            state.Ok = result?.Ok ?? false;
            state.ChannelCount = result?.ChannelCount;
            state.Error = result?.Error;
        }
        catch (Exception ex)
        {
            state.Ok = false;
            state.Error = ex.Message;
        }
        finally
        {
            state.IsProbing = false;
            StateHasChanged();
        }
    }

    private async Task ImportAsync(string name)
    {
        _importError = null;
        _importingName = name;

        try
        {
            var opts = GetImportOptions(name);
            var response = await Http.PostAsJsonAsync("/api/v1/providers/config/import",
                new ImportConfigProviderRequest { Name = name, IncludeVod = opts.IncludeVod, IncludeSeries = opts.IncludeSeries });

            if (!response.IsSuccessStatusCode)
            {
                _importError = await ReadErrorAsync(response);
                return;
            }

            var dto = await response.Content.ReadFromJsonAsync<ProviderDto>();
            if (dto is not null) _importedProviders.Add(dto);
            await OnImported.InvokeAsync(dto?.ProviderId ?? string.Empty);
        }
        catch (Exception ex)
        {
            _importError = $"Failed to import provider: {ex.Message}";
        }
        finally
        {
            _importingName = null;
            StateHasChanged();
        }
    }

    private static async Task<string> ReadErrorAsync(HttpResponseMessage response)
    {
        var body = await response.Content.ReadAsStringAsync();
        if (string.IsNullOrWhiteSpace(body))
            return $"Request failed: {(int)response.StatusCode} {response.ReasonPhrase}";

        try
        {
            using var doc = JsonDocument.Parse(body);
            if (doc.RootElement.ValueKind == JsonValueKind.Object)
            {
                if (doc.RootElement.TryGetProperty("title", out var title))
                {
                    var detail = doc.RootElement.TryGetProperty("detail", out var detailProp)
                        ? detailProp.GetString()
                        : null;
                    return string.IsNullOrWhiteSpace(detail)
                        ? title.GetString() ?? "Request failed"
                        : $"{title.GetString()}: {detail}";
                }

                if (doc.RootElement.TryGetProperty("errors", out var errors) && errors.ValueKind == JsonValueKind.Object)
                {
                    foreach (var error in errors.EnumerateObject())
                    {
                        var first = error.Value.EnumerateArray().FirstOrDefault().GetString();
                        if (!string.IsNullOrWhiteSpace(first)) return first;
                    }
                }
            }
        }
        catch (JsonException) { }

        return body;
    }
}
